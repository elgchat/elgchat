大体的来说缓存有三种读写模式**Cache Aside Pattern**、**Read/Write Through Pattern**、**Write Behind Caching Pattern**

## Cache Aside Pattern 旁路缓存

**Cache Aside Pattern**（旁路缓存），是最经典的缓存➕数据库读写模式

### 读操作

读的时间，先读缓存，缓存没有的时候，就读数据库，然后取出数据后放入缓存，同时返回响应。

<img src="https://elgchat-oss.oss-accelerate.aliyuncs.com/elgchat/2021_06_22/image-20210622114148644.png" alt="image-20210622114148644" style="zoom:50%;" />

### 更新操作

更新的时候，先更新数据库，然后再删除缓存

<img src="https://elgchat-oss.oss-accelerate.aliyuncs.com/elgchat/2021_06_22/image-20210622114352734.png" alt="image-20210622114352734" style="zoom:50%;" />

### 引申问题

#### 1. 为什么是删除缓存而不是更新缓存

1. 缓存的值是一个hash、list结构时，更新数据需要遍历
2. 懒加载，使用的时候更新缓存

#### 2.高并发脏读的几种场景

1. 先更新数据库，再更新缓存
2. 先删除缓存，再更新数据库
3. 先更新数据，再删除缓存



## Read/Write Through Pattern 穿透读写模式

**Read/Write Through Pattern**（穿透读写模式/直读直写模式） 应用程序只操作缓存，缓存操作数据库

Read-Through(穿透读模式/直读模式)：应用程序读缓存，缓存没有，由缓存回源到数据库，并写入 缓存。

Write-Through(穿透写模式/直写模式)：应用程序写缓存，缓存写数据库。 该种模式需要提供数据库的handler，开发较为复杂。



## Write Behind Caching Pattern 缓存后写模式

应用程序只更新缓存。 缓存通过异步的方式将数据批量或合并后更新到DB中 不能时时同步，甚至会丢数据