## 概念

栈（stack）又名堆栈，它是一种运算受限的线性表。栈中的元素只能先入后出(First In Last Out，简称FILO)。

最早进入的元素存放的位置叫做栈底（buttom），反之最后进入的元素存放的位置叫做栈顶（top）

其实很好理解，小时候我们装糖豆的玻璃棒就是这个样子，每次我们只能取出最靠近扣进瓶口的糖豆，这不就是出栈/弹栈，那么反之，我们往进放糖豆的时候，不就是入栈/压栈操作。

![image-20210330183037637](https://elgchat-oss.oss-accelerate.aliyuncs.com/elgchat/2021_03_30/image-20210330183037637.png)

## 存储原理

栈是一种线性结构，那么就可以使用物理结构来存储（顺序存储结构：数组；链式存储结构：链表 ）

栈即可以使用数组实现也可以使用链表实现

### 数组实现

数组实现的栈也叫顺序栈或静态栈

![image-20210330193935525](https://elgchat-oss.oss-accelerate.aliyuncs.com/elgchat/2021_03_30/image-20210330193935525.png)

### 链表实现

链表实现的栈也叫做链式栈或动态栈

![image-20210330194430449](https://elgchat-oss.oss-accelerate.aliyuncs.com/elgchat/2021_03_30/image-20210330194430449.png)

## 操作

* 入栈（压栈）

  入栈操作（push）就是把新元素放入栈内，只允许从栈顶一侧放入元素，新元素的位置将会变成新的栈顶

![image-20210330195302851](https://elgchat-oss.oss-accelerate.aliyuncs.com/elgchat/2021_03_30/image-20210330195302851.png)

* 出栈（弹栈）

  出栈操作（pop）就是把元素从栈中弹出，并且只允许栈顶的元素出栈，出栈元素钱的一个元素将会成为新的栈顶

  ![image-20210330195814929](https://elgchat-oss.oss-accelerate.aliyuncs.com/elgchat/2021_03_30/image-20210330195814929.png)

## 代码实现

### 数组实现

```java
package com.elgchat.learning;

/**
 * 数组实现
 */
public class ArrayStack {
    // 数组
    private int[] nums;
    // 栈中元素个数
    private int count;

    // 初始化数组，申请一个大小为n的数组空间 
    public ArrayStack(int n) {
        this.nums = new int[n];
        this.count = 0;
    }

    // 入栈操作
    public boolean push(int n) {
        // 数组空间不够了，直接返回false，入栈失败。 没有扩容 // nums.len*2 arraycopy
        if (count >= nums.length) {
            return false;
        }
        // 将item放到下标为count的位置，并且count加一 
        nums[count] = n;
        count++;
        return true;
    }

    // 出栈操作
    public int pop() {
        // 栈为空，则直接返回0
        if (count == 0) {
            return 0;
        }
        // 返回下标为count-1的数组元素，并且栈中元素个数count减一 
        int n = nums[count - 1];
        count--;
        return n;
    }

    public static void main(String[] args) {
        ArrayStack as = new ArrayStack(8);
        as.push(3);
        as.push(5);
        as.push(1);
        as.push(4);
        System.out.println(as.pop());
        System.out.println(as.pop());
        System.out.println(as.pop());
        System.out.println(as.pop());
    }
}
```

### 链表实现

```java
package com.elgchat.learning;
public class Node {
    int value;
    Node next;
    public Node(int value) {
        this.value = value;
    }
}
```

```java
package com.elgchat.learning;

/**
 * 链表实现
 */
public class LinedStack {
    int size;
    Node head; //头节点

    /**
     * 初始化
     */
    public LinedStack() {
        head = null;
        size = 0;
    }

    /**
     * 入栈
     *
     * @param node
     */
    public void push(Node node) {
        //head
        if (size == 0) {
            head = node;
        } else {    //非head 
            node.next = head;
            head = node;
        }
        size++;
    }

    /**
     * 出栈
     *
     * @return Node
     */
    public Node pop() {
        if (size > 0) {
            Node oldHead = head;
            head = head.next;
            size--;
            return oldHead;
        } else {
            return null;
        }
    }

    public static void main(String[] args) {
        Node n1 = new Node(3);
        Node n2 = new Node(5);
        Node n3 = new Node(1);
        Node n4 = new Node(4);
        LinedStack ls = new LinedStack();
        ls.push(n1);
        ls.push(n2);
        ls.push(n3);
        ls.push(n4);
        System.out.println(ls.pop().value);
        System.out.println(ls.pop().value);
        System.out.println(ls.pop().value);
        System.out.println(ls.pop().value);
    }
}
```

## 时间复杂度

**入栈和出栈的时间复杂度都是O(1)**

支持动态扩容的顺序栈，当数组空间不够时，就需要重新申请一块更大的内存，将原来数组中数据统统拷贝过去，这样就实现了一个支持动态扩容的数组，可以得知入栈的时间复杂度是O(n)

## 应用

* 函数调用
    每进入一个函数，就会将临时变量作为一个栈入栈，当被调用函数执行完成，返回之后，将这个函
    数对应的栈帧出栈
* 浏览器的后退功能
  我们使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据， 放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数 据，那就说明没有页面可以点击前进按钮浏览了