##  概念

链表(linked list)是一种在物理上非连续、非顺序的数据结构，由若干节点(node)所组成。

链表中数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点(链表中每一个元
素称为结点)组成，结点可以在运行时动态生成。

每个结点包括两个部分:一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。

常见的链表包括:单链表、双向链表、循环链表

### 单链表

单向链表的每一个节点又包含两部分，一部分是存放数据的变量data，另一部分是指向下一个节点的指针next

![image-20210329195550448](https://elgchat-oss.oss-accelerate.aliyuncs.com/elgchat/2021_03_29/image-20210329195550448.png)

```java
Node{
    int data;
		Node next; 
}
```

### 双向链表

双向链表的每一个节点除了拥有data和next指针，还拥有指向前置节点的prev指针。

![image-20210329200247922](https://elgchat-oss.oss-accelerate.aliyuncs.com/elgchat/2021_03_29/image-20210329200247922.png)

```java
Node{
  int data;
	Node next;
	Node prev; 
}
```

### 循环链表

链表的尾节点指向头节点形成一个环，称为循环链表

![image-20210329200626351](https://elgchat-oss.oss-accelerate.aliyuncs.com/elgchat/2021_03_29/image-20210329200626351.png)

### 双向循环链表

![image-20210329200904908](https://elgchat-oss.oss-accelerate.aliyuncs.com/elgchat/2021_03_29/image-20210329200904908.png)

## 存储原理

链表在内存中的存储方式则是随机存储(链式存储)。
链表的每一个节点分布在内存的不同位置，依靠next指针关联起来。这样可以灵活有效地利用零散的碎片空间。![image-20210329202508933](https://elgchat-oss.oss-accelerate.aliyuncs.com/elgchat/2021_03_29/image-20210329202508933.png)

链表的第1个节点被称为头节点(9)，没有任何节点的next指针指向它，或者说它的前置节点为空

头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表

链表的最后1个节点被称为尾节点(8)，它指向的next为空



## 操作

### 查找

在查找元素时，链表只能从头节点开始向后一个一个节点逐一查找。

时间复杂度O(n)

![image-20210329195550448](https://elgchat-oss.oss-accelerate.aliyuncs.com/elgchat/2021_03_29/image-20210329195550448.png)

### 更新节点

找到要更新的节点，然后把旧数据替换成新数据![image-20210329203147434](https://elgchat-oss.oss-accelerate.aliyuncs.com/elgchat/2021_03_29/image-20210329203147434.png)

### 插入节点

* 尾部插入

  把最后一个节点的next指针指向新插入的节点即可

  ![image-20210329203412375](https://elgchat-oss.oss-accelerate.aliyuncs.com/elgchat/2021_03_29/image-20210329203412375.png)

* 头部插入
  1. 把新节点的next指针指向原先的头节点 
  2. 把新节点变为链表的头节点

![image-20210329203614691](https://elgchat-oss.oss-accelerate.aliyuncs.com/elgchat/2021_03_29/image-20210329203614691.png)

* 中间插入
  1. 新节点的next指针，指向插入位置的节点 
  2. 插入位置前置节点的next指针，指向新节点

![image-20210329204020703](https://elgchat-oss.oss-accelerate.aliyuncs.com/elgchat/2021_03_29/image-20210329204020703.png)

​	只要内存空间允许，能够插入链表的元素是无限的，不需要像数组那样考虑扩容的问题

### 删除节点

* 尾部删除

  把倒数第2个节点的next指针指向空即可

  ![image-20210329204259901](https://elgchat-oss.oss-accelerate.aliyuncs.com/elgchat/2021_03_29/image-20210329204259901.png)

* 头部删除

  把链表的头节点设为原先头节点的next指针即可

  ![image-20210329204416722](https://elgchat-oss.oss-accelerate.aliyuncs.com/elgchat/2021_03_29/image-20210329204416722.png)

* 中间删除

  把要删除节点的前置节点的next指针，指向要删除元素的下一个节点即可

![image-20210329204531838](https://elgchat-oss.oss-accelerate.aliyuncs.com/elgchat/2021_03_29/image-20210329204531838.png)

### 实例代码

```java
package com.lagou.line.linkedlist;
/**
 * 单链表 
 */
public class SingleLinkedList { //初始化头节点
    private Node head = new Node(0, "");
  /**
  * 添加节点:从头插入 *
  * @param node
  */
  public void addNode(Node node) { //从头插入
    Node tmp = head;
    while (true) {
      //到尾节点
      if (tmp.next == null) {
        break; 
      }
   	  //后移一个节点
      tmp = tmp.next;
     	}
    tmp.next = node;
  }
  public void addByIdOrder(Node node){ //从头插入
    Node tmp = head;
    while (true) {
      //到尾节点
      if (tmp.next == null) {
      	break; 
      }
 			 //节点存在
  		if (tmp.next.id == node.id) {
  			break; 
      }
      if (tmp.next.id > node.id) {
        break;
      }
      tmp = tmp.next;
  	}
  //交换位置
  	node.next = tmp.next; 
    tmp.next = node;
  }
  //遍历链表
  public void showList() {
    //空链表
    if (head.next == null) {
    	System.out.println("链表为空");
    	return; 
    }
    Node temp = head.next;
    while (true) {
      if (temp == null) {
          return;
      } 
      System.out.println(temp); 
      //指针下移
    	temp = temp.next;
    }
  }
  public static void main(String[] args) {
    Node n1=new Node(1,"张飞"); 
    Node n2=new Node(2,"关羽"); 
    Node n3=new Node(3,"赵云"); 
    Node n4=new Node(4,"黄忠"); 
    Node n5=new Node(5,"马超");
    SingleLinkedList sll=new SingleLinkedList();
    sll.addByIdOrder(n4);
    sll.addByIdOrder(n5);
    sll.addByIdOrder(n1);
    sll.addByIdOrder(n2);
    sll.addByIdOrder(n3);
    sll.showList();
  }
}
```

